import requests
from bs4 import BeautifulSoup
import time
import smtplib
from email.mime.text import MIMEText
from datetime import datetime, timedelta
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
import threading
import re
import uuid
import json
import os
import webbrowser
import winsound
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException

# Headers for web requests
headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
    "Accept-Language": "en-US,en;q=0.9",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
    "Connection": "keep-alive",
    "Referer": "https://www.amazon.com"
}

class StockCheckerApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Stock Checker")
        self.root.geometry("1000x700")
        self.running = False
        self.thread = None
        self.products = []
        self.status_labels = {}
        self.duration_labels = {}
        self.out_of_stock_labels = {}
        self.price_labels = {}
        self.buy_now_buttons = {}
        self.last_amazon_check = 0
        self.current_page = 0
        self.items_per_page = 10
        self.sound_enabled = tk.BooleanVar(value=True)
        self.custom_sound_path = tk.StringVar()
        self.email_config = self.load_email_config()
        self.last_update = time.time()
        self.driver = None  # Selenium WebDriver instance

        # Initialize Selenium WebDriver
        self._setup_selenium()

        # Load products from file
        self.load_products_from_file()

        # Set modern theme
        self.style = ttk.Style()
        self.style.theme_use("clam")
        
        # Configure styles
        self.style.configure("TFrame", background="#f0f2f5")
        self.style.configure("TLabel", background="#f0f2f5", font=("Segoe UI", 10))
        self.style.configure("Header.TLabel", font=("Segoe UI", 11, "bold"), foreground="#2c3e50")
        self.style.configure("TButton", font=("Segoe UI", 10), padding=6)
        self.style.configure("Start.TButton", background="#2ecc71", foreground="white")
        self.style.configure("Stop.TButton", background="#e74c3c", foreground="white")
        self.style.configure("Remove.TButton", font=("Segoe UI", 9), padding=4)
        self.style.configure("BuyNow.TButton", font=("Segoe UI", 9), padding=4, background="#3498db", foreground="white")
        self.style.configure("TEntry", padding=5)
        self.style.configure("TCheckbutton", background="#f0f2f5", font=("Segoe UI", 10))
        self.style.map("TButton", 
                       background=[("active", "#3498db")], 
                       foreground=[("active", "white")])
        self.style.map("Start.TButton", 
                       background=[("active", "#27ae60")])
        self.style.map("Stop.TButton", 
                       background=[("active", "#c0392b")])
        self.style.map("BuyNow.TButton", 
                       background=[("active", "#2980b9")])
        
        # Main frame with tabs
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(padx=15, pady=10, fill="both", expand=True)
        
        # Products tab
        self.products_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.products_frame, text="Products")
        
        # Settings tab
        self.settings_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.settings_frame, text="Settings")
        
        # Product input frame
        self.input_frame = ttk.Frame(self.products_frame)
        self.input_frame.pack(fill="x", pady=10)
        
        # Product input fields
        ttk.Label(self.input_frame, text="Product Name:", style="Header.TLabel").grid(row=0, column=0, padx=10, pady=5, sticky="e")
        self.name_entry = ttk.Entry(self.input_frame, width=30)
        self.name_entry.grid(row=0, column=1, padx=5, pady=5)
        
        ttk.Label(self.input_frame, text="URL/ASIN:", style="Header.TLabel").grid(row=0, column=2, padx=10, pady=5, sticky="e")
        self.url_entry = ttk.Entry(self.input_frame, width=40)
        self.url_entry.grid(row=0, column=3, padx=5, pady=5)
        
        ttk.Button(self.input_frame, text="Add Product", command=self.add_product).grid(row=0, column=4, padx=10, pady=5)
        
        # Products table frame
        self.table_frame = ttk.Frame(self.products_frame)
        self.table_frame.pack(fill="both", expand=True, pady=10)
        
        # Table headers
        headers = ["Product Name", "Status", "In Stock Duration", "Time out of Stock", "Price", "Actions"]
        for col, header in enumerate(headers):
            ttk.Label(self.table_frame, text=header, style="Header.TLabel").grid(row=0, column=col, padx=10, pady=8, sticky="w")
        
        # Pagination controls
        self.pagination_frame = ttk.Frame(self.products_frame)
        self.pagination_frame.pack(fill="x", pady=5)
        self.prev_button = ttk.Button(self.pagination_frame, text="Previous", command=self.prev_page, state="disabled")
        self.prev_button.pack(side="left", padx=10)
        self.page_label = ttk.Label(self.pagination_frame, text="Page 1", style="Header.TLabel")
        self.page_label.pack(side="left", padx=10)
        self.next_button = ttk.Button(self.pagination_frame, text="Next", command=self.next_page, state="disabled")
        self.next_button.pack(side="left", padx=10)
        
        # Sound control
        self.sound_check = ttk.Checkbutton(self.pagination_frame, text="Enable Sound Notifications", variable=self.sound_enabled)
        self.sound_check.pack(side="left", padx=10)
        
        # Log area
        self.log = scrolledtext.ScrolledText(self.products_frame, height=12, width=100, font=("Segoe UI", 9), 
                                            background="#ffffff", borderwidth=1, relief="solid")
        self.log.pack(padx=10, pady=10, fill="x")
        self.log.config(state="disabled")
        
        # Buttons
        self.button_frame = ttk.Frame(self.products_frame)
        self.button_frame.pack(pady=10)
        self.start_button = ttk.Button(self.button_frame, text="Start Monitoring", command=self.start_monitoring, style="Start.TButton")
        self.start_button.pack(side="left", padx=10)
        self.stop_button = ttk.Button(self.button_frame, text="Stop Monitoring", command=self.stop_monitoring, 
                                      style="Stop.TButton", state="disabled")
        self.stop_button.pack(side="left", padx=10)
        self.help_button = ttk.Button(self.button_frame, text="Help", command=self.show_help_dialog)
        self.help_button.pack(side="left", padx=10)
        
        # Settings tab content
        self.settings_content = ttk.Frame(self.settings_frame)
        self.settings_content.pack(padx=20, pady=20, fill="both", expand=True)
        
        ttk.Label(self.settings_content, text="Edit Email Settings", font=("Segoe UI", 12, "bold"), anchor="center").pack(pady=10)
        ttk.Label(self.settings_content, text="Update your Gmail credentials for notifications.\nSee Help menu for instructions on obtaining an app-specific password.", 
                  font=("Segoe UI", 10), anchor="center", justify="center", wraplength=600).pack(pady=10)
        
        ttk.Label(self.settings_content, text="Sender Email:", font=("Segoe UI", 10), anchor="center").pack(pady=5)
        self.settings_sender_entry = ttk.Entry(self.settings_content, width=40)
        self.settings_sender_entry.insert(0, self.email_config["sender"])
        self.settings_sender_entry.pack(pady=5)
        
        ttk.Label(self.settings_content, text="Receiver Email:", font=("Segoe UI", 10), anchor="center").pack(pady=5)
        self.settings_receiver_entry = ttk.Entry(self.settings_content, width=40)
        self.settings_receiver_entry.insert(0, self.email_config["receiver"])
        self.settings_receiver_entry.pack(pady=5)
        
        ttk.Label(self.settings_content, text="App-Specific Password:", font=("Segoe UI", 10), anchor="center").pack(pady=5)
        self.settings_password_entry = ttk.Entry(self.settings_content, width=40, show="*")
        self.settings_password_entry.insert(0, self.email_config["password"])
        self.settings_password_entry.pack(pady=5)
        
        ttk.Button(self.settings_content, text="Save Changes", command=self.save_email_settings).pack(pady=10)
        
        ttk.Label(self.settings_content, text="Custom Sound File:", font=("Segoe UI", 10), anchor="center").pack(pady=5)
        ttk.Entry(self.settings_content, textvariable=self.custom_sound_path, width=40, state="readonly").pack(pady=5)
        ttk.Button(self.settings_content, text="Upload Sound", command=self.upload_sound).pack(pady=5)
        ttk.Button(self.settings_content, text="Test Notification Sound", command=self.test_notification_sound).pack(pady=10)

        # Update table with loaded products
        self.update_product_table()
        self.root.after(0, self.update_out_of_stock_times)  # Start timer immediately

    def _setup_selenium(self):
        """Initialize Selenium WebDriver with headless Chrome."""
        chrome_options = Options()
        chrome_options.add_argument("--headless")
        chrome_options.add_argument("--disable-gpu")
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--enable-unsafe-swiftshader")  # To address WebGL warnings
        self.driver = webdriver.Chrome(options=chrome_options)

    def play_notification_sound(self):
        """Play notification sound if enabled, using custom sound if set."""
        if self.sound_enabled.get():
            try:
                sound_path = self.custom_sound_path.get() or None
                if sound_path and os.path.exists(sound_path):
                    winsound.PlaySound(sound_path, winsound.SND_FILENAME)
                else:
                    winsound.Beep(1000, 200)
            except Exception as e:
                self.log_message(f"Error playing notification sound: {e}")

    def test_notification_sound(self):
        """Test the notification sound."""
        self.play_notification_sound()
        self.log_message("Notification sound tested.")

    def upload_sound(self):
        """Upload a custom notification sound file."""
        file_path = filedialog.askopenfilename(filetypes=[("WAV files", "*.wav")])
        if file_path:
            self.custom_sound_path.set(file_path)
            self.log_message(f"Custom sound file uploaded: {file_path}")

    def show_help_dialog(self):
        """Display a help dialog with instructions for Gmail app-specific password."""
        dialog = tk.Toplevel(self.root)
        dialog.title("Help: Gmail Credentials")
        dialog.geometry("600x400")
        dialog.transient(self.root)
        dialog.grab_set()

        help_text = """
        How to Set Up Gmail for Notifications
        ====================================

        This app sends email notifications for Walmart stock changes and Amazon price drops.
        You need a Gmail account with an app-specific password. Follow these steps:

        1. Enable 2-Step Verification:
           - Go to your Google Account (https://myaccount.google.com).
           - Click 'Security' in the left menu.
           - Under 'Signing in to Google,' click '2-Step Verification.'
           - Follow the prompts to enable it (e.g., using your phone).

        2. Generate an App-Specific Password:
           - In Google Account 'Security' settings, find 'App passwords' (under '2-Step Verification').
           - Click 'Generate' to create a new password.
           - Select 'Mail' as the app and 'Other' as the device, then name it (e.g., 'Stock Checker').
           - Copy the 16-character password (e.g., xxxx xxxx xxxx xxxx).

        3. Enter Credentials in the App:
           - In the initial prompt or Settings tab, enter your Gmail address in 'Sender Email' and 'Receiver Email.'
           - Paste the app-specific password into the 'App-Specific Password' field.
           - Click 'Save' to store credentials.

        Notes:
        - Sender and Receiver Email can be the same Gmail address.
        - Do not use your regular Gmail password; it won't work.
        - If you reset 2-Step Verification, generate a new app-specific password.
        - For issues, check the log in the Products tab for error messages.
        """
        text_widget = tk.Text(dialog, wrap="word", height=20, width=70, font=("Segoe UI", 10))
        text_widget.insert("1.0", help_text)
        text_widget.config(state="disabled")
        text_widget.pack(padx=10, pady=10, fill="both", expand=True)

        ttk.Button(dialog, text="Close Window", command=dialog.destroy).pack(pady=20)

    def load_email_config(self):
        """Load email configuration from config.json or prompt for credentials."""
        config_file = "config.json"
        default_config = {
            "sender": "",
            "receiver": "",
            "password": ""
        }
        if os.path.exists(config_file):
            try:
                with open(config_file, "r") as f:
                    config = json.load(f)
                    if all(key in config for key in ["sender", "receiver", "password"]):
                        return config
            except Exception as e:
                self.log_message(f"Error loading email config: {e}")
        
        config = self.prompt_email_credentials()
        try:
            with open(config_file, "w") as f:
                json.dump(config, f, indent=4)
        except Exception as e:
            self.log_message(f"Error saving email config: {e}")
        return config

    def prompt_email_credentials(self):
        """Prompt user for email credentials."""
        dialog = tk.Toplevel(self.root)
        dialog.title("Email Configuration")
        dialog_width = 400
        dialog_height = 350
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        x = (screen_width - dialog_width) // 2
        y = (screen_height - dialog_height) // 2
        dialog.geometry(f"{dialog_width}x{dialog_height}+{x}+{y}")
        dialog.transient(self.root)
        dialog.grab_set()

        main_frame = ttk.Frame(dialog)
        main_frame.pack(expand=True)

        ttk.Label(main_frame, text="Enter Gmail credentials for notifications:", font=("Segoe UI", 10), anchor="center", justify="center").pack(pady=10)
        ttk.Label(main_frame, text="Use a Gmail app-specific password (click Help below).\nSender and Receiver Email can be the same.", 
                  font=("Segoe UI", 9), anchor="center", justify="center", wraplength=350).pack(pady=10)
        
        ttk.Label(main_frame, text="Sender Email:", font=("Segoe UI", 10), anchor="center", justify="center").pack(pady=5)
        sender_entry = ttk.Entry(main_frame, width=40)
        sender_entry.pack(pady=5)
        
        ttk.Label(main_frame, text="Receiver Email:", font=("Segoe UI", 10), anchor="center", justify="center").pack(pady=5)
        receiver_entry = ttk.Entry(main_frame, width=40)
        receiver_entry.pack(pady=5)
        
        ttk.Label(main_frame, text="App-Specific Password:", font=("Segoe UI", 10), anchor="center", justify="center").pack(pady=5)
        password_entry = ttk.Entry(main_frame, width=40, show="*")
        password_entry.pack(pady=5)
        
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=20)
        ttk.Button(button_frame, text="Help", command=self.show_help_dialog).pack(side="left", padx=5)
        ttk.Button(button_frame, text="Submit", command=lambda: save_credentials(sender_entry, receiver_entry, password_entry, dialog)).pack(side="left", padx=5)

        dialog.bind("<Return>", lambda event: save_credentials(sender_entry, receiver_entry, password_entry, dialog))

        config = {}
        def save_credentials(sender_entry, receiver_entry, password_entry, dialog):
            config["sender"] = sender_entry.get().strip()
            config["receiver"] = receiver_entry.get().strip()
            config["password"] = password_entry.get().strip()
            if config["sender"] and config["receiver"] and config["password"]:
                self.send_test_email(config)
                dialog.destroy()
            else:
                messagebox.showerror("Error", "All fields are required.")

        self.root.wait_window(dialog)
        return config

    def send_test_email(self, config):
        """Send a test notification email to verify configuration."""
        try:
            msg = MIMEText("This is a test notification from Stock Checker to confirm your email setup works.")
            msg['Subject'] = "Test Notification - Stock Checker"
            msg['From'] = config["sender"]
            msg['To'] = config["receiver"]
            with smtplib.SMTP('smtp.gmail.com', 587) as server:
                server.starttls()
                server.login(config["sender"], config["password"])
                server.sendmail(config["sender"], config["receiver"], msg.as_string())
            self.log_message("Test email sent successfully!")
        except Exception as e:
            self.log_message(f"Error sending test email: {e}")

    def save_email_settings(self):
        """Save updated email settings from the Settings tab."""
        config = {
            "sender": self.settings_sender_entry.get().strip(),
            "receiver": self.settings_receiver_entry.get().strip(),
            "password": self.settings_password_entry.get().strip()
        }
        if config["sender"] and config["receiver"] and config["password"]:
            self.email_config = config
            try:
                with open("config.json", "w") as f:
                    json.dump(config, f, indent=4)
                self.send_test_email(config)
                self.log_message("Email settings updated successfully.")
            except Exception as e:
                self.log_message(f"Error saving email settings: {e}")
        else:
            messagebox.showerror("Error", "All fields are required.")

    def load_products_from_file(self):
        """Load products from products.json or start with an empty list."""
        try:
            if os.path.exists("products.json"):
                with open("products.json", "r") as f:
                    products = json.load(f)
                    for prod in products:
                        prod["id"] = prod.get("id", str(uuid.uuid4()))
                        prod["in_stock_start_time"] = None if prod.get("in_stock_start_time") == "None" else (datetime.fromisoformat(prod.get("in_stock_start_time")) if prod.get("in_stock_start_time") else None)
                        prod["out_of_stock_start_time"] = None if prod.get("out_of_stock_start_time") == "None" else (datetime.fromisoformat(prod.get("out_of_stock_start_time")) if prod.get("out_of_stock_start_time") else None)
                        prod["is_in_stock"] = prod.get("is_in_stock", False)
                        prod["last_price"] = prod.get("last_price", None)
                        prod["is_amazon"] = prod.get("is_amazon", "amazon.com" in prod["url"].lower())
                        prod["price_drop_detected"] = prod.get("price_drop_detected", False)
                    self.products = products
            else:
                self.products = []
        except json.JSONDecodeError as e:
            self.log_message(f"Error loading products from file: Invalid JSON at line {e.lineno} column {e.colno} (char {e.pos}): {str(e)}. Initializing empty product list.")
            self.products = []
        except Exception as e:
            self.log_message(f"Error loading products from file: {e}")
            self.products = []

    def save_products_to_file(self):
        """Save products to products.json with datetime conversion."""
        try:
            products_to_save = []
            for product in self.products:
                product_copy = product.copy()
                if product_copy.get("in_stock_start_time"):
                    product_copy["in_stock_start_time"] = product_copy["in_stock_start_time"].isoformat()
                else:
                    product_copy["in_stock_start_time"] = "None"
                if product_copy.get("out_of_stock_start_time"):
                    product_copy["out_of_stock_start_time"] = product_copy["out_of_stock_start_time"].isoformat()
                else:
                    product_copy["out_of_stock_start_time"] = "None"
                products_to_save.append(product_copy)
            with open("products.json", "w") as f:
                json.dump(products_to_save, f, indent=4)
        except Exception as e:
            self.log_message(f"Error saving products to file: {e}")

    def add_product(self):
        name = self.name_entry.get().strip()
        url_or_asin = self.url_entry.get().strip()
        if not name or not url_or_asin:
            messagebox.showerror("Error", "Please enter both product name and URL/ASIN")
            return
            
        if re.match(r'^[A-Z0-9]{10}$', url_or_asin):
            url = f"https://www.amazon.com/dp/{url_or_asin}"
        else:
            url = url_or_asin
            
        self.add_product_to_list(name, url)
        self.name_entry.delete(0, tk.END)
        self.url_entry.delete(0, tk.END)

    def add_product_to_list(self, name, url):
        product = {
            "id": str(uuid.uuid4()),
            "name": name,
            "url": url,
            "in_stock_start_time": None,
            "out_of_stock_start_time": None,
            "is_in_stock": False,
            "last_price": None,
            "is_amazon": "amazon.com" in url.lower(),
            "price_drop_detected": false
        }
        self.products.append(product)
        self.save_products_to_file()
        self.update_product_table()
        if self.running:
            threading.Thread(target=self.check_stock, args=(product,), daemon=True).start()

    def remove_product(self, product_id):
        self.products = [p for p in self.products if p["id"] != product_id]
        self.save_products_to_file()
        self.update_product_table()

    def prev_page(self):
        if self.current_page > 0:
            self.current_page -= 1
            self.update_product_table()

    def next_page(self):
        if (self.current_page + 1) * self.items_per_page < len(self.products):
            self.current_page += 1
            self.update_product_table()

    def update_product_table(self):
        for widget in self.table_frame.winfo_children()[len(["Product Name", "Status", "In Stock Duration", "Time out of Stock", "Price", "Actions"]):]:
            widget.destroy()
            
        start_idx = self.current_page * self.items_per_page
        end_idx = min(start_idx + self.items_per_page, len(self.products))
        current_products = self.products[start_idx:end_idx]
        
        for i, product in enumerate(current_products, 1):
            row_bg = "#ffffff" if (i + start_idx) % 2 == 0 else "#f5f6fa"
            self.style.configure(f"Row{i}.TLabel", background=row_bg)
            
            ttk.Label(self.table_frame, text=product["name"], style=f"Row{i}.TLabel").grid(row=i, column=0, padx=10, pady=6, sticky="w")
            
            if not product["is_amazon"]:
                self.status_labels[product["id"]] = ttk.Label(self.table_frame, text="Out of Stock", foreground="#e74c3c", style=f"Row{i}.TLabel")
                self.status_labels[product["id"]].grid(row=i, column=1, padx=10, pady=6, sticky="w")
                
                self.duration_labels[product["id"]] = ttk.Label(self.table_frame, text="N/A", style=f"Row{i}.TLabel")
                self.duration_labels[product["id"]].grid(row=i, column=2, padx=10, pady=6, sticky="w")
                
                self.out_of_stock_labels[product["id"]] = ttk.Label(self.table_frame, text="N/A", style=f"Row{i}.TLabel")
                self.out_of_stock_labels[product["id"]].grid(row=i, column=3, padx=10, pady=6, sticky="w")
                
                self.price_labels[product["id"]] = ttk.Label(self.table_frame, text="N/A", style=f"Row{i}.TLabel")
                self.price_labels[product["id"]].grid(row=i, column=4, padx=10, pady=6, sticky="w")
            else:
                self.status_labels[product["id"]] = ttk.Label(self.table_frame, text="", style=f"Row{i}.TLabel")
                self.status_labels[product["id"]].grid(row=i, column=1, padx=10, pady=6, sticky="w")
                self.duration_labels[product["id"]] = ttk.Label(self.table_frame, text="", style=f"Row{i}.TLabel")
                self.duration_labels[product["id"]].grid(row=i, column=2, padx=10, pady=6, sticky="w")
                self.out_of_stock_labels[product["id"]] = ttk.Label(self.table_frame, text="", style=f"Row{i}.TLabel")
                self.out_of_stock_labels[product["id"]].grid(row=i, column=3, padx=10, pady=6, sticky="w")
                
                self.price_labels[product["id"]] = ttk.Label(self.table_frame, text="N/A", style=f"Row{i}.TLabel")
                self.price_labels[product["id"]].grid(row=i, column=4, padx=10, pady=6, sticky="w")
            
            action_frame = ttk.Frame(self.table_frame)
            action_frame.grid(row=i, column=5, padx=10, pady=6, sticky="w")
            ttk.Button(action_frame, text="Remove", style="Remove.TButton",
                      command=lambda pid=product["id"]: self.remove_product(pid)).pack(side="left", padx=5)
            if (not product["is_amazon"] and product["is_in_stock"]) or (product["is_amazon"] and product.get("price_drop_detected", False)):
                self.buy_now_buttons[product["id"]] = ttk.Button(action_frame, text="Buy Now", style="BuyNow.TButton",
                                                               command=lambda url=product["url"]: webbrowser.open(url))
                self.buy_now_buttons[product["id"]].pack(side="left", padx=5)

        self.page_label.config(text=f"Page {self.current_page + 1} of {max(1, (len(self.products) + self.items_per_page - 1) // self.items_per_page)}")
        self.prev_button.config(state="normal" if self.current_page > 0 else "disabled")
        self.next_button.config(state="normal" if end_idx < len(self.products) else "disabled")

    def log_message(self, message):
        def update_log():
            self.log.config(state="normal")
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            self.log.insert(tk.END, f"[{timestamp}] {message}\n")
            self.log.see(tk.END)
            self.log.config(state="disabled")
        self.root.after(0, update_log)

    def send_email(self, product_name, product_url, message):
        try:
            msg = MIMEText(f"{product_name}: {message}\nURL: {product_url}")
            msg['Subject'] = f'Item Alert: {product_name}'
            msg['From'] = self.email_config["sender"]
            msg['To'] = self.email_config["receiver"]
            with smtplib.SMTP('smtp.gmail.com', 587) as server:
                server.starttls()
                server.login(self.email_config["sender"], self.email_config["password"])
                server.sendmail(self.email_config["sender"], self.email_config["receiver"], msg.as_string())
            self.log_message(f"Email sent for {product_name}: {message}")
        except Exception as e:
            self.log_message(f"Error sending email for {product_name}: {e}")

    def show_price_drop_popup(self, product_name, price_change, current_price):
        def auto_close_popup(window):
            time.sleep(5)
            if window.winfo_exists():
                window.destroy()
        
        popup = tk.Toplevel(self.root)
        popup.title("Price Drop Alert")
        popup.geometry("300x100")
        popup.transient(self.root)
        popup.grab_set()
        ttk.Label(popup, text=f"Price Drop for {product_name}!\n"
                             f"Decreased by ${abs(price_change):.2f} to ${current_price:.2f}",
                  font=("Segoe UI", 10)).pack(pady=20)
        threading.Thread(target=auto_close_popup, args=(popup,), daemon=True).start()

    def check_stock(self, product, retry_count=0, max_retries=2):
        try:
            current_time = datetime.now()
            is_in_stock = False
            current_price = None
            
            if product["is_amazon"]:
                response = requests.get(product["url"], headers=headers, timeout=15)
                self.log_message(f"HTTP status for {product['name']}: {response.status_code}")
                response.raise_for_status()
                soup = BeautifulSoup(response.text, 'html.parser')
                add_to_cart = soup.find(id="add-to-cart-button")
                is_in_stock = bool(add_to_cart)
                
                price_selectors = [
                    ("span", {"class": "a-price"}),
                    ("span", {"class": "a-offscreen"}),
                    ("span", {"class": "a-color-price"}),
                    ("span", {"id": "priceblock_ourprice"}),
                    ("span", {"id": "priceblock_dealprice"}),
                    ("span", {"id": "price_inside_buybox"}),
                    ("span", {"class": "apexPriceToPay"})
                ]
                for tag, attrs in price_selectors:
                    price_elem = soup.find(tag, attrs)
                    if price_elem:
                        if "a-price" in attrs.get("class", []):
                            price_whole = price_elem.find("span", class_="a-price-whole")
                            price_fraction = price_elem.find("span", class_="a-price-fraction")
                            if price_whole and price_fraction:
                                try:
                                    current_price = float(f"{price_whole.text.strip('.')}.{price_fraction.text}")
                                    break
                                except ValueError as e:
                                    self.log_message(f"Error parsing Amazon price (a-price) for {product['name']}: {e}")
                        else:
                            try:
                                price_text = price_elem.text.strip().replace('$', '').replace(',', '')
                                current_price = float(price_text)
                                break
                            except ValueError as e:
                                self.log_message(f"Error parsing Amazon price ({attrs.get('class', attrs.get('id'))}) for {product['name']}: {e}")
                if not current_price:
                    price_container = soup.find("div", id="price")
                    self.log_message(f"No valid price found for Amazon product {product['name']} at {product['url']}. HTML snippet: {str(price_container)[:200] if price_container else 'No price container'}")
                    if retry_count < max_retries:
                        self.log_message(f"Retrying Amazon price check for {product['name']} ({retry_count + 1}/{max_retries})")
                        time.sleep(2)
                        return self.check_stock(product, retry_count + 1, max_retries)
            else:
                # Use Selenium for Walmart dynamic content
                self.driver.get(product["url"])
                try:
                    # Wait for the price element to load with increased timeout
                    price_element = WebDriverWait(self.driver, 20).until(
                        EC.presence_of_element_located((By.CSS_SELECTOR, "span[itemprop='price'][data-seo-id='hero-price'][data-fs-element='price']"))
                    )
                    price_text = price_element.text.strip().replace('$', '').replace(',', '')
                    try:
                        current_price = float(price_text)
                    except ValueError as e:
                        self.log_message(f"Error parsing Walmart price for {product['name']}: {e}")
                        current_price = None
                except TimeoutException:
                    self.log_message(f"Timeout waiting for primary price element for {product['name']} at {product['url']}")
                    try:
                        # Fallback to XPath if CSS selector fails
                        price_element = WebDriverWait(self.driver, 10).until(
                            EC.presence_of_element_located((By.XPATH, "/html/body/div[1]/div[1]/div/div[2]/div[1]/section/main/div[2]/div[2]/div/div[3]/div/div[1]/div/div/span[1]/span[2]/span"))
                        )
                        price_text = price_element.text.strip().replace('$', '').replace(',', '')
                        try:
                            current_price = float(price_text)
                        except ValueError as e:
                            self.log_message(f"Error parsing Walmart fallback price for {product['name']}: {e}")
                            current_price = None
                    except (TimeoutException, NoSuchElementException):
                        self.log_message(f"No valid price found for Walmart product {product['name']} at {product['url']}")

                # Stock check with Selenium
                add_to_cart = self.driver.find_elements(By.CSS_SELECTOR, "button.prod-ProductCTA--primary[aria-disabled='false']")
                stock_text = self.driver.find_elements(By.XPATH, "//*[contains(text(), 'in stock') or contains(text(), 'left')]")
                out_of_stock = self.driver.find_elements(By.XPATH, "//*[contains(text(), 'out of stock') or contains(text(), 'unavailable')]")
                oos_indicator = self.driver.find_elements(By.CSS_SELECTOR, "div[data-testid='item-stack-buyable-oos']")
                
                is_in_stock = len(add_to_cart) > 0 or len(stock_text) > 0 and len(out_of_stock) == 0 and len(oos_indicator) == 0
                self.log_message(f"Walmart stock check for {product['name']}: add_to_cart={len(add_to_cart) > 0}, stock_text='{stock_text[0].text[:50] if stock_text else None}', out_of_stock='{out_of_stock[0].text[:50] if out_of_stock else None}', oos_indicator={len(oos_indicator) > 0}")

                if is_in_stock:
                    time.sleep(5)
                    self.driver.get(product["url"])  # Refresh to double-check
                    try:
                        add_to_cart = self.driver.find_elements(By.CSS_SELECTOR, "button.prod-ProductCTA--primary[aria-disabled='false']")
                        stock_text = self.driver.find_elements(By.XPATH, "//*[contains(text(), 'in stock') or contains(text(), 'left')]")
                        out_of_stock = self.driver.find_elements(By.XPATH, "//*[contains(text(), 'out of stock') or contains(text(), 'unavailable')]")
                        oos_indicator = self.driver.find_elements(By.CSS_SELECTOR, "div[data-testid='item-stack-buyable-oos']")
                        is_in_stock = len(add_to_cart) > 0 or len(stock_text) > 0 and len(out_of_stock) == 0 and len(oos_indicator) == 0
                        self.log_message(f"Walmart double-check for {product['name']}: add_to_cart={len(add_to_cart) > 0}, stock_text='{stock_text[0].text[:50] if stock_text else None}', out_of_stock='{out_of_stock[0].text[:50] if out_of_stock else None}', oos_indicator={len(oos_indicator) > 0}")
                    except Exception as e:
                        self.log_message(f"Error in double-check for {product['name']}: {e}")
                        is_in_stock = False

            def update_gui():
                if not product["is_amazon"]:
                    if is_in_stock and not product["is_in_stock"]:
                        product["is_in_stock"] = True
                        product["in_stock_start_time"] = current_time
                        product["out_of_stock_start_time"] = None
                        self.status_labels[product["id"]].config(text="In Stock", foreground="#2ecc71")
                        self.duration_labels[product["id"]].config(text="N/A")
                        self.out_of_stock_labels[product["id"]].config(text="N/A")
                        self.log_message(f"ðŸŽ‰ {product['name']} is IN STOCK! URL: {product['url']}")
                        self.send_email(product["name"], product["url"], "Now in stock!")
                        self.play_notification_sound()
                        self.update_product_table()
                    
                    elif is_in_stock and product["is_in_stock"]:
                        duration = current_time - product["in_stock_start_time"]
                        duration_str = str(timedelta(seconds=int(duration.total_seconds())))
                        self.duration_labels[product["id"]].config(text=duration_str)
                        self.out_of_stock_labels[product["id"]].config(text="N/A")
                        self.log_message(f"â„¹ï¸ {product['name']} is still IN STOCK. Available for: {duration_str}")
                    
                    elif not is_in_stock and product["is_in_stock"]:
                        duration = current_time - product["in_stock_start_time"]
                        duration_str = str(timedelta(seconds=int(duration.total_seconds())))
                        self.status_labels[product["id"]].config(text="Out of Stock", foreground="#e74c3c")
                        self.duration_labels[product["id"]].config(text="N/A")
                        self.out_of_stock_labels[product["id"]].config(text="N/A")
                        self.log_message(f"âŒ {product['name']} is now OUT OF STOCK. Was available for: {duration_str}")
                        self.send_email(product["name"], product["url"], f"Out of stock after {duration_str}")
                        product["is_in_stock"] = False
                        product["out_of_stock_start_time"] = current_time
                        self.update_product_table()
                    
                    else:
                        self.status_labels[product["id"]].config(text="Out of Stock", foreground="#e74c3c")
                        self.duration_labels[product["id"]].config(text="N/A")
                        self.update_product_table()
                
                if current_price is not None:
                    self.price_labels[product["id"]].config(text=f"${current_price:.2f}")
                    if product["last_price"] is not None and current_price != product["last_price"]:
                        price_change = current_price - product["last_price"]
                        change_text = f"Price {'increased' if price_change > 0 else 'decreased'} by ${abs(price_change):.2f}"
                        self.log_message(f"ðŸ’° {product['name']} price changed from ${product['last_price']:.2f} to ${current_price:.2f}")
                        if price_change < 0 and product["is_amazon"]:  # Price drop notification only for Amazon
                            self.send_email(product["name"], product["url"], f"Price decreased by ${abs(price_change):.2f}. New price: ${current_price:.2f}")
                            self.show_price_drop_popup(product["name"], price_change, current_price)
                            product["price_drop_detected"] = True
                            self.play_notification_sound()
                            self.update_product_table()
                        else:
                            product["price_drop_detected"] = False
                            self.update_product_table()
                    product["last_price"] = current_price
                else:
                    self.price_labels[product["id"]].config(text="N/A")

            self.root.after(0, update_gui)
            return is_in_stock
        except requests.exceptions.RequestException as e:
            self.log_message(f"Network error checking stock for {product['name']}: {e}")
            if product["is_amazon"] and retry_count < max_retries:
                self.log_message(f"Retrying Amazon price check for {product['name']} ({retry_count + 1}/{max_retries})")
                time.sleep(2)
                return self.check_stock(product, retry_count + 1, max_retries)
            return product["is_in_stock"]
        except Exception as e:
            self.log_message(f"Unexpected error checking stock for {product['name']}: {e}")
            return product["is_in_stock"]

    def update_out_of_stock_times(self):
        """Update 'Time out of Stock' for all out-of-stock products every minute."""
        current_time = datetime.now()
        for product in self.products:
            if not product["is_amazon"] and not product["is_in_stock"] and product["out_of_stock_start_time"]:
                out_of_stock_duration = current_time - product["out_of_stock_start_time"]
                out_of_stock_minutes = int(out_of_stock_duration.total_seconds() // 60)
                out_of_stock_str = str(timedelta(minutes=out_of_stock_minutes))
                if product["id"] in self.out_of_stock_labels:
                    self.out_of_stock_labels[product["id"]].config(text=out_of_stock_str)
                    self.log_message(f"Updated 'Time out of Stock' for {product['name']} to {out_of_stock_str}")
        self.save_products_to_file()
        if self.running:  # Only schedule next update if monitoring is active
            self.root.after(60000, self.update_out_of_stock_times)

    def monitor_stock(self):
        AMAZON_CHECK_INTERVAL = 1800
        while self.running:
            current_time = time.time()
            for product in self.products:
                if not self.running:
                    break
                if product["is_amazon"] and current_time - self.last_amazon_check < AMAZON_CHECK_INTERVAL:
                    continue
                self.check_stock(product)
            if any(p["is_amazon"] for p in self.products):
                self.last_amazon_check = current_time
            if self.running:
                self.log_message("Checking again in 1 minute...")
                time.sleep(60)

    def start_monitoring(self):
        if not self.running:
            self.running = True
            self.start_button.config(state="disabled")
            self.stop_button.config(state="normal")
            self.log_message("Started monitoring products...")
            self.thread = threading.Thread(target=self.monitor_stock)
            self.thread.daemon = True
            self.thread.start()
            self.root.after(0, self.update_out_of_stock_times)  # Start timer immediately

    def stop_monitoring(self):
        self.running = False
        if self.driver:
            self.driver.quit()  # Clean up WebDriver on stop
        self.start_button.config(state="normal")
        self.stop_button.config(state="disabled")
        self.log_message("Stopped monitoring products.")

if __name__ == "__main__":
    root = tk.Tk()
    app = StockCheckerApp(root)
    root.mainloop()